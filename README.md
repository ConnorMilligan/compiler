# Compiler Construction Final
Compiler Construction Final project by Connor Milligan & Matt Rieger

# Features
## Error messages
Throughout my experience in this class, a consistent challenge I faced was interpereting errors when they were thrown. I decided that while Connor did work on many of the more cerebral elements of this assignment, I would go through and try to go through and add specialized exceptions in places which could potentially throw errors to make for a much easier debugging process. The bulk of my work went into the typechecker pass, as this pass is the one specifically designed to throw errors. Until now, no errors thrown came with an accompanying explanation, and many were simply left to the compiler to throw. I continuously ran the code using different test cases to find as many errors as I could, and then added code to raise an exception with an accompanying explanation of what caused the error. While Connor's code ended up working well and therefore many of my later error messages became moot, future developments using this project as a base could find them very useful, rather than using the traceback method proided by the base python compiler.
## Binary compiler
This proved to be challenging, but actually quite fun to do. Being unfamiliar with the purpose of the runtime C files, it was interesting to actually figure out why they were there. When it came to the actual implementation, it was mostly just going through the actual main function, which had remained untouched in previous projects until now. Looking through the code, it seemed that the compiler already just outputted assembly code without any sort of compilation. This made adding the `-S` flag trivial. On that note as well, the actual flags proved to be quite easy with the help of a python library. For the `-o` flag, it was simple just to substitute the default output filename with a variable set by the flag. Now with assembly output and output names done, it came time to tackle the actual compilation. First matter of business was an assembler, I had originally chosen to use NASM, as it is an assembler I had worked with in the past, but I quickly realized that the output of the compiler follows AT&T syntax. This actually proved to be a good thing, as I could simply use the GNU assembler. Considering I was already planning on using the linker provided in GCC, this helped simplify dependencies. The rest of the task was simply writing a function that acted not unlike a shell script, just excepting commands that were required to compile as I would do so manually. With all that done, all the features I had envisioned for this feature were done. Using a library called pyinstaller (Added to a requirements.txt), I was able to condense the project into a simple binary which could be thrown into the a folder on a systems path and run independently from the command line. While the program does output valid binaries, they are unable to run due to a failing assertion, something about the rootstock size doesn't seem to be working, which could be a local issue, but I was unfortunately unable to figure it out.
## PLEASE syntax
From the start, an important feature for us was to ensure our program was as polite as possible, to accomplish this we would seek to include INTERCAL style syntax to ensure our programmers would not forget their manners. To begin, we were looking to see how to implement this hopefully as a keyword. This proved to be difficult, as the parsing of the abstract syntax tree required us to directly modify the support code which would prove problematic. The support code is also beyond my understanding of the python programming language, so attempts to make modifications were unsuccessful. To get around this it was required for us to just have a variable with a set name that stored a junk value. This of course was quite disappointing, but the functionality still is correct. Essentially, a programmer is required to make use of a variable called `PLEASE` in somewhere between 20-40% of the program, too little and the programmer will not be polite enough, and the program will refuse to compile, too many and programmer will have been too polite, causing the same. Originally, i was looking to include this in one of the passes, `typechecker` seemed the most logical. This proved to be impossible to do reliably since the inclusion of functions to our language, since the compiler passes are now segmented. This required us to create a new pass the precedes the typechecker, appropriately named the `politeness pass` this pass will check for occurrences of the `PLEASE` variable, and throw an exception, similar to how it does in our error messages. This pass coming before all others ensures that computational resources will no be wasted on a program destined to never be able to compile.
